class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        # 맨 오른쪽 비트를 변경하거나
        # i번째 비트의 이후의 비트가 100....이어야만 변경할 수 있음.
        # DP를 쓸 수 있으려나? n <= 10^9니까 2진수로 나타내면 길이가 30 정도?
        # 근데 특정 비트 상태에서... 2번 작업은 하면 되고
        # 1번 작업은 비트를 돌면서 x10 이런 형태인지 검증해야 할 듯?
        # 0이 되면 연산의 횟수를 반환하고, 0이 안 될 수도 있음. 그러면 float("inf")를 반환하고
        # 근데 그러면 DP가 맞나? subproblem이 되나? DP가 아닌 것 같음. 뭔가 패턴이 있을텐데...

        # 1 -> 0: 1개.
        # 10 -> 11 -> 01. 2개 + 1개 => 3개.
        # 100 -> 101 -> 111 -> 110 -> 010. 4개 + 3개. 7개.
        # 1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 0100. 8개 + 7개. 15개.
        # 2^k인 경우 2^(k + 1) - 1개 필요.

        # 근데 1010.. 이런 애들을 1000으로 어케 만들지? 그게 subproblem이었음.
        # 1111이면? 1000 - 100 - 10 - 1
        # 1010이면? 1000 - 10
        res = 0
        k = 0
        mask = 1
        while mask <= n:
            if n & mask:
                res = 2 ** (k + 1) - 1 - res
            
            mask <<= 1
            k += 1
        
        return res